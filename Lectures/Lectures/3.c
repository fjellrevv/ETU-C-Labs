/*
29.09

cprintf
int st = '\' ' -  апостроф
int st = '\'' ' -  двойные кавычки

ОПЕРАЦИИ (унарные)

++ инкремент a++
-- декремент --a
sizeof размер или тип данных в байтах
пример: sizeof(int); (4)
sizeof (a) (4) (int a)
~ разрядное отрицание
! логическое отрицание
- унарный минус
+ унарный плюс
(mun) явное преобразование типов

ОПЕРАЦИИ (бинарные)

+
-
*
/
==
!=
& побитное умножение
&& 1 или 0 логическое
| побитное умножение
|| 1 или 0 логическое

? тернарная операция

ПРЕОБРАЗОВАНИЕ ТИПОВ ДАННЫХ 
все данные типов char и short int преобразуются к типу int
если хотя бы один из операндов имеет тип double, то и другой из операндов преобразуется к типу double, и результат вычисления имеет тип double
если хотя бы один из операндов имеет тип float, то и другой из операндов преобразуется к типу float, и результат вычисления имеет тип float
если хотя бы один из операндов имеет тип long, то и другой из операндов преобразуется к типу long, и результат вычисления имеет тип long
если хотя бы один из операндов имеет тип unsigned, то и другой из операндов преобразуется к типу unsigned, и результат вычисления имеет тип unsigned

unsigned a = 5
int b = 10
cout << a << "-" << b << "=" << a-b
5-10 = 4294967298 (инверсия) с -5 одна двоичная запись
cout << a << "-" << b << "=" << (int)a-b
5-10 = -5

(int) 3.14
int (3.14)
одно и то же

short a = 100
преобразование без потерь
cout << (int)a << endl; 100 
cout << (char)a << endl; d
cout << (float)a << endl; 100
cout << (double)a << endl; 100

с потерей точности
float b = 3,14
cout << (double)b << endl;
cout << (int)b << endl; 3

с потерей данных
<..>

short a = -100
cout unsigned 4 миллиарда
a = 50000
cout short -15000(тк старший бит равен единице и число отрицательное)

cpp: static cast <тип данных> (выражение)
static cast <double> (a+2e+40f)

операция присваивания = последний приоритет

int i = 100000, k
short j = 10000, m
k = j
m = i
cout << k << m
10000 -31072

int i = 7 j = 10
++j
j++
cout << ++i << "\t" << j++ << endl 8 10
cout << j 11
--i
j--

*/